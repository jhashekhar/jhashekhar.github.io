<!DOCTYPE html>
<html lang="en-US">
  <head>

    
    <meta charset="UTF-8">

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Diffusion Limited Aggregation | Shekhar Jha</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Diffusion Limited Aggregation" />
<meta name="author" content="Shekhar Jha" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Diffusion Limited Aggregation import matplotlib.pyplot as plt import numpy as np import random import sys sys.setrecursionlimit(15000) # dla simulator # let&#39;s create a blank 500x500 matrix and plot it x = np.zeros((5, 5)) x x = np.zeros((500, 500)) x[300, 300] = 1.0 plt.imshow(x) plt.show() x = np.zeros((500, 500)) for n in range(10000): random_x = random.randint(0, 499) random_y = random.randint(0, 499) x[random_x, random_y] = 1.0 plt.imshow(x) plt.show() N = 400 # (x = 0, y = range(0, 500)), (x = 499, y=range(0, 500)), (x = range(0, 500), y = 0), (x = range(0, 500), y = 499) # choose a cell randomly along the border def choose_border_cells(): bnd_cell = [] bnd_cell.append((0, random.randint(0, N-1))) bnd_cell.append((N-1, random.randint(0, N-1))) bnd_cell.append((random.randint(0, N-1), 0)) bnd_cell.append((random.randint(0, N-1), N-1)) choose_i, choose_j = random.choice(bnd_cell) return choose_i, choose_j def conditions(x, y): return [x &lt; 0, x &gt; N-1, y &lt; 0, y &gt; N-1] # choosing new coordinates from neighbor coordinates def random_walk(current_i, current_j): i, j = current_i, current_j coordinates = [(i-1, j-1), (i-1, j), (i-1, j+1), (i, j-1), (i, j+1), (i+1, j-1), (i+1, j), (i+1, j+1)] res_coordinates = [] for (x, y) in coordinates: condition = conditions(x, y) if any(condition): pass else: res_coordinates.append((x, y)) #print(res_coordinates) new_i, new_j = random.choice(res_coordinates) return new_i, new_j random_walk(0, 0) (0, 1) choose_i, choose_j = choose_border_cells() choose_i, choose_j (0, 241) #choose_i, choose_j = choose_border_cells() x = np.zeros((400, 400)) x[199, 199] = 1.0 def loopy(): count = 0 #choose_i, choose_j = choose_border_cells() for n in range(32000): count += 1 prev_i, prev_j = choose_border_cells() # random walk returns new coordinates new_i, new_j = random_walk(prev_i, prev_j) #print(prev_i, prev_j) #print(new_i, new_j) while x[new_i, new_j] != 1.0: x[new_i, new_j] = 1.0 x[prev_i, prev_j] = 0.0 prev_i, prev_j = new_i, new_j new_i, new_j = random_walk(prev_i, prev_j) else: #print(prev_i, prev_j) x[prev_i, prev_j] = 1.0 continue return x, count y, count = loopy() count 32000 plt.figure(figsize=(10, 10)) plt.imshow(y) plt.show()" />
<meta property="og:description" content="Diffusion Limited Aggregation import matplotlib.pyplot as plt import numpy as np import random import sys sys.setrecursionlimit(15000) # dla simulator # let&#39;s create a blank 500x500 matrix and plot it x = np.zeros((5, 5)) x x = np.zeros((500, 500)) x[300, 300] = 1.0 plt.imshow(x) plt.show() x = np.zeros((500, 500)) for n in range(10000): random_x = random.randint(0, 499) random_y = random.randint(0, 499) x[random_x, random_y] = 1.0 plt.imshow(x) plt.show() N = 400 # (x = 0, y = range(0, 500)), (x = 499, y=range(0, 500)), (x = range(0, 500), y = 0), (x = range(0, 500), y = 499) # choose a cell randomly along the border def choose_border_cells(): bnd_cell = [] bnd_cell.append((0, random.randint(0, N-1))) bnd_cell.append((N-1, random.randint(0, N-1))) bnd_cell.append((random.randint(0, N-1), 0)) bnd_cell.append((random.randint(0, N-1), N-1)) choose_i, choose_j = random.choice(bnd_cell) return choose_i, choose_j def conditions(x, y): return [x &lt; 0, x &gt; N-1, y &lt; 0, y &gt; N-1] # choosing new coordinates from neighbor coordinates def random_walk(current_i, current_j): i, j = current_i, current_j coordinates = [(i-1, j-1), (i-1, j), (i-1, j+1), (i, j-1), (i, j+1), (i+1, j-1), (i+1, j), (i+1, j+1)] res_coordinates = [] for (x, y) in coordinates: condition = conditions(x, y) if any(condition): pass else: res_coordinates.append((x, y)) #print(res_coordinates) new_i, new_j = random.choice(res_coordinates) return new_i, new_j random_walk(0, 0) (0, 1) choose_i, choose_j = choose_border_cells() choose_i, choose_j (0, 241) #choose_i, choose_j = choose_border_cells() x = np.zeros((400, 400)) x[199, 199] = 1.0 def loopy(): count = 0 #choose_i, choose_j = choose_border_cells() for n in range(32000): count += 1 prev_i, prev_j = choose_border_cells() # random walk returns new coordinates new_i, new_j = random_walk(prev_i, prev_j) #print(prev_i, prev_j) #print(new_i, new_j) while x[new_i, new_j] != 1.0: x[new_i, new_j] = 1.0 x[prev_i, prev_j] = 0.0 prev_i, prev_j = new_i, new_j new_i, new_j = random_walk(prev_i, prev_j) else: #print(prev_i, prev_j) x[prev_i, prev_j] = 1.0 continue return x, count y, count = loopy() count 32000 plt.figure(figsize=(10, 10)) plt.imshow(y) plt.show()" />
<link rel="canonical" href="http://localhost:4000/2020/01/19/diffusion_limited_agg.html" />
<meta property="og:url" content="http://localhost:4000/2020/01/19/diffusion_limited_agg.html" />
<meta property="og:site_name" content="Shekhar Jha" />
<meta property="og:image" content="https://jhashekhar.github.io/assets/img/diffusion_limited_agg.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-01-19T00:00:00+05:30" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"Shekhar Jha"},"image":"https://jhashekhar.github.io/assets/img/diffusion_limited_agg.png","headline":"Diffusion Limited Aggregation","dateModified":"2020-01-19T00:00:00+05:30","description":"Diffusion Limited Aggregation import matplotlib.pyplot as plt import numpy as np import random import sys sys.setrecursionlimit(15000) # dla simulator # let&#39;s create a blank 500x500 matrix and plot it x = np.zeros((5, 5)) x x = np.zeros((500, 500)) x[300, 300] = 1.0 plt.imshow(x) plt.show() x = np.zeros((500, 500)) for n in range(10000): random_x = random.randint(0, 499) random_y = random.randint(0, 499) x[random_x, random_y] = 1.0 plt.imshow(x) plt.show() N = 400 # (x = 0, y = range(0, 500)), (x = 499, y=range(0, 500)), (x = range(0, 500), y = 0), (x = range(0, 500), y = 499) # choose a cell randomly along the border def choose_border_cells(): bnd_cell = [] bnd_cell.append((0, random.randint(0, N-1))) bnd_cell.append((N-1, random.randint(0, N-1))) bnd_cell.append((random.randint(0, N-1), 0)) bnd_cell.append((random.randint(0, N-1), N-1)) choose_i, choose_j = random.choice(bnd_cell) return choose_i, choose_j def conditions(x, y): return [x &lt; 0, x &gt; N-1, y &lt; 0, y &gt; N-1] # choosing new coordinates from neighbor coordinates def random_walk(current_i, current_j): i, j = current_i, current_j coordinates = [(i-1, j-1), (i-1, j), (i-1, j+1), (i, j-1), (i, j+1), (i+1, j-1), (i+1, j), (i+1, j+1)] res_coordinates = [] for (x, y) in coordinates: condition = conditions(x, y) if any(condition): pass else: res_coordinates.append((x, y)) #print(res_coordinates) new_i, new_j = random.choice(res_coordinates) return new_i, new_j random_walk(0, 0) (0, 1) choose_i, choose_j = choose_border_cells() choose_i, choose_j (0, 241) #choose_i, choose_j = choose_border_cells() x = np.zeros((400, 400)) x[199, 199] = 1.0 def loopy(): count = 0 #choose_i, choose_j = choose_border_cells() for n in range(32000): count += 1 prev_i, prev_j = choose_border_cells() # random walk returns new coordinates new_i, new_j = random_walk(prev_i, prev_j) #print(prev_i, prev_j) #print(new_i, new_j) while x[new_i, new_j] != 1.0: x[new_i, new_j] = 1.0 x[prev_i, prev_j] = 0.0 prev_i, prev_j = new_i, new_j new_i, new_j = random_walk(prev_i, prev_j) else: #print(prev_i, prev_j) x[prev_i, prev_j] = 1.0 continue return x, count y, count = loopy() count 32000 plt.figure(figsize=(10, 10)) plt.imshow(y) plt.show()","datePublished":"2020-01-19T00:00:00+05:30","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/01/19/diffusion_limited_agg.html"},"@type":"BlogPosting","url":"http://localhost:4000/2020/01/19/diffusion_limited_agg.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#157878">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="stylesheet" href="/assets/css/style.css?v=02c300a0f92af7caec805c47321d25041154c0dc">
  </head>
  <body>
  <header class="neo-header">
    <left-item><a href="../../../blog.html">Blog</a></left-item>
    <right-item><a href="../../../index.html">Home</a></right-item>
    <hr>
  </header>
    <main id="content" class="main-content" role="main">
      <title-head><h2><u>Diffusion Limited Aggregation</u></h2></title-head>
<p><br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import matplotlib.pyplot as plt
import numpy as np

import random
import sys
sys.setrecursionlimit(15000)

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># dla simulator

</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># let's create a blank 500x500 matrix and plot it
x = np.zeros((5, 5))
x
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = np.zeros((500, 500))
x[300, 300] = 1.0
plt.imshow(x)
plt.show()
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x = np.zeros((500, 500))

for n in range(10000):
    random_x = random.randint(0, 499)
    random_y = random.randint(0, 499)
    x[random_x, random_y] = 1.0

plt.imshow(x)
plt.show()
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N = 400

# (x = 0, y = range(0, 500)), (x = 499, y=range(0, 500)), (x = range(0, 500), y = 0), (x = range(0, 500), y = 499)
# choose a cell randomly along the border
def choose_border_cells():
    bnd_cell = []

    bnd_cell.append((0, random.randint(0, N-1)))
    bnd_cell.append((N-1, random.randint(0, N-1)))
    bnd_cell.append((random.randint(0, N-1), 0))
    bnd_cell.append((random.randint(0, N-1), N-1))

    choose_i, choose_j = random.choice(bnd_cell)
    return choose_i, choose_j


def conditions(x, y):
    return [x &lt; 0, x &gt; N-1, y &lt; 0, y &gt; N-1]

# choosing new coordinates from neighbor coordinates
def random_walk(current_i, current_j):

    i, j = current_i, current_j
    coordinates = [(i-1, j-1), (i-1, j), (i-1, j+1),
                   (i, j-1), (i, j+1),
                   (i+1, j-1), (i+1, j), (i+1, j+1)]

    res_coordinates = []

    for (x, y) in coordinates:
        condition = conditions(x, y)
        if any(condition):
            pass
        else:
            res_coordinates.append((x, y))
    #print(res_coordinates)
    new_i, new_j = random.choice(res_coordinates)
    return new_i, new_j
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>random_walk(0, 0)
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0, 1)
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>choose_i, choose_j = choose_border_cells()
choose_i, choose_j
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(0, 241)
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#choose_i, choose_j = choose_border_cells()
x = np.zeros((400, 400))
x[199, 199] = 1.0

def loopy():
    count = 0
    #choose_i, choose_j = choose_border_cells()
    for n in range(32000):
        count += 1
        prev_i, prev_j = choose_border_cells()
        # random walk returns new coordinates
        new_i, new_j = random_walk(prev_i, prev_j)
        #print(prev_i, prev_j)
        #print(new_i, new_j)

        while x[new_i, new_j] != 1.0:
            x[new_i, new_j] = 1.0
            x[prev_i, prev_j] = 0.0
            prev_i, prev_j = new_i, new_j
            new_i, new_j = random_walk(prev_i, prev_j)
        else:
            #print(prev_i, prev_j)
            x[prev_i, prev_j] = 1.0
            continue

    return x, count

y, count = loopy()
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>count
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>32000
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plt.figure(figsize=(10, 10))
plt.imshow(y)
plt.show()
</code></pre></div></div>

<p><img src="https://jhashekhar.github.io/assets/img/diffusion_limited_agg.png" width="400px" height="400px" align="center" /></p>

    </main>
  </body>
</html>